{*******************************************************************************
* Module Name   : $LTE_INFOMAKER
*
* Purpose       : LTE code for Infomaker
*
* Portability   : Not Checked
*
* Re-entrant    : No
********************************************************************************} 
{*** IMPLEMENTAÇÃO THERMO ***}
{ 
No.	Data	Quem	O que
08/01/2013	Mudanças para correção de BUG - todas
}
SET NOTPROTECTED

ENABLE WINDOWS
SET NAME "DISPLAY/"

JOIN STANDARD_LIBRARY STD_ARRAY
JOIN STANDARD_LIBRARY STD_BROWSE
JOIN STANDARD_LIBRARY STD_CLIENT
JOIN STANDARD_LIBRARY STD_STRUCTURE

JOIN LIBRARY $LABTABLIB
JOIN LIBRARY $LIB_UTILS
JOIN LIBRARY $PROMPT_IMPRINT

{**Local Constants ************************************************************} 


{** Global Constants **********************************************************} 

{** Global Variables **********************************************************} 

{** Main Code *****************************************************************} 


{* Start Of Routines **********************************************************} 

{******************************************************************************}

{ --------------------------------------------------------------------------- }

{ --------------- Initialization Statements : DO NOT CHANGE ----------------- }



{ --------------------------------------------------------------------------- }


{ -------------------------- Table Setup Routine ---------------------------- }

ROUTINE table_setup

	ARRAY prompt_details	ARRAY_SIZE ( 0 , 6 )
	ARRAY fields_to_output  ARRAY_SIZE ( 0 )

{

	CHANGE : Specify the name of the table in <name_of_table>
                 eg   name_of_table = "HAZARD"

}

	name_of_table           =  "INFOMAKER_LINK"

{

	CHANGE : MANDATORY : Specify the text to be displayed at the top
                 of the data entry screen in <header_mess>.
                 Note that the text may be specified literally
                 eg   header_mess = "Hazard Data Entry Screen"
                 or may be extracted from the message file
                 eg   header_mess = GET MESSAGE(xyz)

}

	header_mess = GET_USER_MESSAGE ( "INFOMAKER_LINK_LTE_INFO_REPORT", 1 ) 

{

	CHANGE : MANDATORY : Specify the text to be displayed at the bottom
                 of the data entry screen in <footer_mess> for the options
                 add , copy , modify but not display.
                 Note that the text may be specified literally
                 eg   footer_mess = "Press DO to Save / EXIT to Quit"
                 or may be extracted from the message file
                 eg   footer_mess = GET MESSAGE(xyz)

}

	footer_mess = GET_USER_MESSAGE ( "INFOMAKER_LINK_LTE_FOOTER", 1 ) 

{

	CHANGE : MANDATORY : Specify the text to be displayed at the bottom
                 of the data entry screen in <display_footer_mess> for the
		 display option.
                 Note that the text may be specified literally
                 eg   footer_mess = "Press EXIT to Quit"
                 or may be extracted from the message file
                 eg   footer_mess = GET MESSAGE(xyz)

}

	display_footer_mess = GET_USER_MESSAGE ( "INFOMAKER_LINK_LTE_DISP_FOOTER", 1 ) 

{

	CHANGE : MANDATORY : Specify the names of the fields and the
                 text associated with each field to be displayed on the
                 screen.
                 For each field the field name is stored in an element
                 of array <prompt_details> with an index of FIELD_NAME_POSITION
                 and the message stored with an index of MESSAGE_POSITION.
                 This array will require expanding for the total number
		 of fields required on the screen.

                 e.g
		prompt_details [ 1 , MESSAGE_POSITION    ] = "Group Name"
        	prompt_details [ 1 , FIELD_NAME_POSITION ] = "GROUP_ID"

		prompt_details [ 1 , MESSAGE_POSITION    ] = "Hazard Label Text"
		prompt_details [ 1 , FIELD_NAME_POSITION ] = "LABEL_TEXT"

		prompt_details [ 1 , MESSAGE_POSITION    ] = "Description"
		prompt_details [ 1 , FIELD_NAME_POSITION ] = "DESCRIPTION"

		prompt_details [ 1 , MESSAGE_POSITION    ] = "Modifiable Entry"
		prompt_details [ 1 , FIELD_NAME_POSITION ] = "MODIFIABLE"

                The text may be specified literally as shown above
                or extracted from the message file using GET MESSAGE

}

            count = 1
		prompt_details [ count , MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "LTE_GROUP_DISP_NAME" , 1 )
        	prompt_details [ count , FIELD_NAME_POSITION ] = "GROUP_ID"

            count = count + 1

		prompt_details [ count , MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INFOMAKER_LINK_LTE_DESC", 1 ) 
        	prompt_details [ count , FIELD_NAME_POSITION ] = "DESCRIPTION"


            count = count + 1
		prompt_details [ count , MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INFOMAKER_LINK_LTE_INFO_LIB", 1 ) 
		prompt_details [ count , FIELD_NAME_POSITION ] = "LIBRARY"

            count = count + 1
		prompt_details [ count , MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INFOMAKER_LINK_LTE_INFO_REPORT", 1 ) 
		prompt_details [ count , FIELD_NAME_POSITION ] = "REPORT"

            count = count + 1
		prompt_details [ count , MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INFOMAKER_LINK_LTE_USER_LIB", 1 ) 
		prompt_details [ count , FIELD_NAME_POSITION ] = "USER_LIBRARY"

            count = count + 1
		prompt_details [ count , MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INFOMAKER_LINK_LTE_VALID_ROUTINE", 1 ) 
		prompt_details [ count , FIELD_NAME_POSITION ] = "VALID_ROUTINE"

            count = count + 1
		prompt_details [ count , MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INFOMAKER_LINK_LTE_PRINT_PREV", 1 ) 
		prompt_details [ count , FIELD_NAME_POSITION ] = "PREVIEW"

            count = count + 1
		prompt_details [ count , MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INFOMAKER_LINK_LTE_COPIES", 1 ) 
		prompt_details [ count , FIELD_NAME_POSITION ] = "COPIES"

            count = count + 1

		prompt_details [ count , MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INFOMAKER_LINK_LTE_MODIFIABLE", 1 ) 
        	prompt_details [ count , FIELD_NAME_POSITION ] = "MODIFIABLE"
{

	CHANGE : Specify the name of the table to be displayed on the screen
                 in <displayed_name_of_table>. This is useful for foreign
                 language support.
                 eg   displayed_name_of_table = "Hazard"

}

	displayed_name_of_table    = GET_USER_MESSAGE ( "INFOMAKER_LINK_LTE_DISP_NAME", 1 ) 

{

	CHANGE : Specify the name of the directory where text files are stored
                 which may contain descriptive information in <directory> and
                 the extension of the file in <extn>. If there is no associated
                 text file then these should be set to EMPTY.
                 For instance the hazard table.
                 eg   directory = "SMP$TEXTFILES"
                      extn = "HAZ"
                 or
                      directory = EMPTY
                      extn = EMPTY

}

	directory = EMPTY
	extn = EMPTY

{

	CHANGE : MANDATORY : Specify the text to be displayed when prompting
                 for an identifier.
                 Note that the text may be specified literally
                 eg   input_mess  = "Enter Hazard ID : "
                 or may be extracted from the message file
                 eg   input_mess = GET MESSAGE(xyz)

}

	input_mess = GET_USER_MESSAGE ( "INFOMAKER_LINK_LTE_ENTER_REP", 1 ) 

{

	CHANGE : OPTIONAL : Specify default unique key value for new additions
		to the table - the default values for any new entry to the
		table will be copied from this entry in the database.
                Set <default_value> to be empty to ignore this feature.

		e.g
		  default_value = "DEFAULT"

}

	default_value = EMPTY

{

	CHANGE : MANDATORY : Specify the number of the fields to appear
                on the output generated by the list option.
                For each field to be output on the list an element of the array
		<fields_to_output> should contain a number corresponding to
		the position of that field in the array <prompt_details>.
		This array can be of any size from zero elements to the
		size of the arrays <prompt_details>.

		e.g
		  fields_to_output [ 1 ] = 1
		  fields_to_output [ 2 ] = 4
		  fields_to_output [ 3 ] = 3

}

	fields_to_output [ 1 ]  = "1"
	fields_to_output [ 2 ]  = "2"
	fields_to_output [ 3 ]  = "3"
	fields_to_output [ 4 ]  = "4"
	fields_to_output [ 5 ]  = "5"

{

	CHANGE : OPTIONAL : Specify a special action to happen on pressing the
			     <select> key.

                CHARACTER_POSITION index contains a character for the menu item.
                TITLE_POSITION     index contains a title for the menu item.
                LIBRARY_POSITION   index contains the library to call.
                ROUTINE_POSITION   index contains a routine in the library.

	eg

	special_actions_report [ 1 , CHARACTER_POSITION ] = "*"
	special_actions_report [ 1 , TITLE_POSITION     ] = "Analysis Options"

	special_actions_report [ 2 , CHARACTER_POSITION ] = "1"
	special_actions_report [ 2 , TITLE_POSITION     ] = "1 Analysis Components"
	special_actions_report [ 2 , LIBRARY_POSITION   ] = "$COMP_EDIT"
	special_actions_report [ 2 , ROUTINE_POSITION   ] = "LABTABLE_INPUT"

	special_actions_report [ 3 , CHARACTER_POSITION ] = "2"
	special_actions_report [ 3 , TITLE_POSITION     ] = "2 Analysis Description"
	special_actions_report [ 3 , LIBRARY_POSITION   ] = "$LABTABLIB"
	special_actions_report [ 3 , ROUTINE_POSITION   ] = "TEXT_FILE"

}

	ARRAY 	special_actions_report 	ARRAY_SIZE ( 0 , 4 )

	special_actions_report [ 1 , CHARACTER_POSITION ] = "*"
	special_actions_report [ 1 , TITLE_POSITION     ] = GET_USER_MESSAGE ( "INFOMAKER_LINK_LTE_INFO_OPTIONS", 1 ) 

      special_actions_report [ 2 , CHARACTER_POSITION ] = "1"
      special_actions_report [ 2 , TITLE_POSITION     ] = GET_USER_MESSAGE ( "INFOMAKER_LINK_LTE_INFO_FIELDS", 1 ) 
      special_actions_report [ 2 , LIBRARY_POSITION   ] = "$INFOMAKER_PARAMS"
      special_actions_report [ 2 , ROUTINE_POSITION   ] = "LTE_ENTRY_POINT"

{

	special_actions_report [ 1 , CHARACTER_POSITION ] = "1"
	special_actions_report [ 1 , TITLE_POSITION     ] = "1 Phrase List"
	special_actions_report [ 1 , LIBRARY_POSITION   ] = "$PHRASE"
	special_actions_report [ 1 , ROUTINE_POSITION   ] = "DO_PHRASE_LIST"

}

{

	CHANGE : OPTIONAL : Specify five standard messages.

                IDENTITY1_MESSAGE contains title text for the identity field.
                MOD_ON_MESSAGE    contains title text for the Modified On field.
                MOD_BY_MESSAGE    contains title text for the Modified by field.
                READ_MESSAGE      contains identifier for the read transaction.
                WRITE_MESSAGE     contains identifier for the write transaction

		Note:
		Where a table contains more than one key0 field, then messages
		for the second (and third and fourth, if appropriate) key0
		fields should be set up in the IDENTITY2_MESSAGE,
		IDENTITY3_MESSAGE and IDENTITY3_MESSAGE elements.

}

        ARRAY 	labtable_messages 	ARRAY_SIZE ( 0 )

        labtable_messages [ IDENTITY1_MESSAGE ] = GET MESSAGE ( 2545 , 1 )
					        { "Identity" }
        labtable_messages [ IDENTITY2_MESSAGE ] = GET MESSAGE ( 2884 , 1 )
					        { "Identity 2" }
        labtable_messages [ IDENTITY3_MESSAGE ] = GET MESSAGE ( 2884 , 2 )
					        { "Identity 3" }
        labtable_messages [ IDENTITY4_MESSAGE ] = GET MESSAGE ( 2884 , 3 )
					        { "Identity 4" }
        labtable_messages [ MOD_ON_MESSAGE    ] = GET MESSAGE ( 2546 , 1 )
						{ "Modified On" }
        labtable_messages [ MOD_BY_MESSAGE    ] = GET MESSAGE ( 2547 , 1 )
                                                { "Modified By" }
        labtable_messages [ READ_MESSAGE      ] = GET MESSAGE ( 2566 , 1 )
                                                { "Labtable Read Transaction" }
        labtable_messages [ WRITE_MESSAGE     ] = GET MESSAGE ( 2567 , 1 )
                                                { "Labtable Write Transaction" }

{

	CHANGE : MANDATORY : Specify the help context for the editor window.
		 The text should be specified literally and should start
		 with the name of the report, suffixed with "_EDIT",
		 	i.e. "$LTE_XXX_EDIT"

}

	help_context = "$LTE_TEM_EDIT"


 {   ------	THERE ARE NO MORE FIELDS TO BE SETUP  --------    }

ENDROUTINE

{ --------------------------------------------------------------------------- }
{                                                                             }
{ The following routines are provided as call back points for LTE processing. }
{ User code may be added as appropriate.                                      }
{ --------------------------------------------------------------------------- }

ROUTINE validation_routine

	DECLARE report, pbl, handled
	
	handled = FALSE

	{ Called on pressing the DO key to save LTE screen.               }
	{ Called outside of the LTE write transaction.                    }
        {                                                                 }
	{ Returns a boolean value to indicate whether to proceed with     }
	{ the save process - if FALSE is returned the user is forced back }
	{ into the editor                                                 }

	pbl = SELECT infomaker_link . library
	report = SELECT infomaker_link . report

	IF ( NOT BLANK ( pbl ) ) AND 
	   ( NOT BLANK ( report ) ) THEN
	
	handled = TRUE
	
	ENDIF
	
	IF NOT handled THEN
	
		flash_message ( 
			GET_USER_MESSAGE ( "INFOMAKER_LINK_ERROR_INVALID_REPORT" , 1 ) , 1 )
	ENDIF


	RETURN ( handled )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE prompt_object_routine (       prompt_object ,
                                VALUE key0_count    ,
                                VALUE operation     )

	{ Called during the creation of the identity prompts              }
        {                                                                 }
	{ prompt_object is the prompt object fro the specified prompt     }
	{ key0_count    is the current key0 segment number                }
	{               eg this would be 2 for the version_number         }
	{                  field of the versioned_analysis table          }
	{ operation     the current LTE operation eg ADD, MODIFY, DISPLAY }
        {                                                                 }
	{ No return value is required                                     }

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE create_id_routine

	{ Called before starting the identity prompts of an LTE for the   }
	{ ADD and COPY options.                                           }
	{                                                                 }
	{ The return value is used as the identity of the new record      }
	{ instead of starting the identity prompts.                       }
	{ Returning EMPTY causes the identity prompt to be started.       }

        RETURN ( EMPTY )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE update_routine ( labtable )

	{ Called on pressing the DO key to save LTE screen.               }
	{ Called after the LTE write transaction has been started.        }
	{                                                                 }
	{ labtable is the labtable object.                                }
	{                                                                 }
	{ The return value is TRUE  if updates have been performed        }
	{                     FALSE if updates have NOT been performed    }
	{                     EMPTY - the systems checks for updates      }

        RETURN ( FALSE )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE read_data_routine (       labtable  ,
                            VALUE operation )

	{ Called after the record has been selected / reserved but before }
	{ the editor screen has been built.                               }
        {                                                                 }
	{ labtable      the labtable object.                              }
	{ operation     the current LTE operation eg ADD, MODIFY, DISPLAY }
        {                                                                 }
	{ No return value is required                                     }

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE validate_new_id_routine ( VALUE new_id )

	{ Called after each ID value has been entered.                    }
	{                                                                 }
	{ new_id is the value entered at the prompt.                      }
	{                                                                 }
	{ Returns a boolean value to indicate whether the value is valid. }

	RETURN ( TRUE )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE do_the_work  ( VALUE operation )

table_setup ()
smp_lte_perform_option  ( name_of_table              ,
	    	          displayed_name_of_table    ,
			  prompt_details             ,
                          labtable_messages          ,
                          default_value		     ,
                          input_mess		     ,
		          header_mess                ,
		          footer_mess                ,
			  display_footer_mess        ,
			  directory                  ,
			  extn                       ,
			  help_context               ,
		          GLOBAL ("CURRENT_LIBRARY") ,
			  fields_to_output           ,
			  special_actions_report     ,
			  operation                  )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE add_option ( option )

do_the_work ( "add_ident" )

ENDROUTINE


{ --------------------------------------------------------------------------- }

ROUTINE copy_option ( option )

do_the_work ( "copy_ident" )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE modify_option ( option )

do_the_work ( "modify_ident" )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE display_option ( option )

do_the_work ( "display_ident" )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE remove_option ( option )

do_the_work ( "remove_ident" )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE restore_option ( option )

do_the_work ( "restore_ident" )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE list_option ( option )

do_the_work ( "list_idents" )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE print_option ( option )

do_the_work ( "print_ident" )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE smp_lte_initialise

ENDROUTINE

{******************************************************************************}

{* Prompt Routines ************************************************************}

ROUTINE find_pbl_name ( prompt_object )

{
* Summary    : RMB menu routine
*
* Parameters : standard rmb parameters
*
* Return     : None
*
*******************************************************************************}

	DECLARE pbl_name,
	        client_browse,
	        imprint_path

	pbl_name = SELECT infomaker_link . library

	IF pbl_name = EMPTY THEN

		pbl_name = ""

	ENDIF


	IF GLOBAL ( "OLEIMPRINT_SERVER_SIDE" ) THEN

		imprint_path  = "smp$imprint"
		client_browse = FALSE
		
	ELSE

		imprint_path  = client_get_imprint_path ()
		client_browse = TRUE
		
	ENDIF

	PROMPT OBJECT prompt_object    
	BROWSE ON FILE
	ON LINE 1 FROM 15
	WITH ( 	file_extension = "pbl" 				,
	   	file_directory = imprint_path 			,
	   	client_file = client_browse 			,
	   	leave_prompt_routine = "strip_off_filename" 	,
	   	vgl_library = GLOBAL ( "CURRENT_LIBRARY" ) 	)

        
ENDROUTINE

{******************************************************************************}

ROUTINE browse_for_pbl ( self )

{
* Summary    : Browse, for infomaker pbl.
*
* Parameters : self - prompt
*
* Return     : None
*
*******************************************************************************}


    file_name = self . value

    { directory = client_get_imprint_path ( ) }
    directory = "SMP$IMPRINT"

    IF directory = EMPTY THEN

        flash_message ( GET_USER_MESSAGE ("INFOMAKER_LINK_ERROR_BROWSE_SMW",1 ) , 
        		TRUE )

    ELSE

        filter = "Powerbuilder Libraries (*.pbl) | *.pbl"

        new_file_name = client_find_file (  
			TRUE          , 
			file_name     ,
			directory     , 
			filter        , 
			GET_USER_MESSAGE ( "INFOMAKER_LINK_REP_TO_RUN" , 1 ) ,
			""	       )

    ENDIF


ENDROUTINE

{******************************************************************************}

ROUTINE browse_reports ( prompt_object )

{
* Summary    : Browse for infomaker reports
*
* Parameters : prompt object
*
* Return     : None
*
*******************************************************************************}

    PROMPT OBJECT prompt_object
        FORMAT TEXT50
        WITH (  browse_routine = "report_list" ,
        	validation_routine = "validate_browse_reports" )

ENDROUTINE

{******************************************************************************}

ROUTINE validate_browse_reports ( self )

{
* Summary    : Validate report entered into the reports field
*
* Parameters : prompt object
*
* Return     : If report is valid
*
*******************************************************************************}


	DECLARE handled, pbl_name
	
	handled  = FALSE
		
	pbl_name = SELECT infomaker_link . library
	{ 001
	handled = valid_infomaker_report ( pbl_name , self . value )
	001 }
	handled = TRUE

	IF NOT handled THEN

		flash_message ( 
			GET_USER_MESSAGE ( "INFOMAKER_LINK_ERROR_INVALID_REPORT" , 1 ) , 1 )
	ENDIF
	
	RETURN ( handled )
	
	

ENDROUTINE

{******************************************************************************}

GLOBAL

ROUTINE strip_file_from_path ( file_name )

{
* Summary    : Takes file path and returns file name only.
*
* Parameters : file path
*
* Return     : file name
*
*******************************************************************************}


    DECLARE slash_pos , str_len , result

    IF INDEX ( file_name , "smp$imprint/" ) > 0 THEN
    
        result = file_name # "smp$imprint/"
        
    ELSE
    
        result = STRIP ( file_name )

        slash_pos = INDEX ( result , "\" )

        WHILE ( slash_pos > 0 ) DO

            str_len = LENGTH ( result )

            result = RIGHTSTRING ( result , str_len - slash_pos )

            slash_pos = INDEX ( result , "\" )
            
            {Check for server additions}
            IF slash_pos = 0 THEN
            	slash_pos = INDEX ( result , "/" )
            ENDIF

        ENDWHILE

    ENDIF
    
    RETURN ( result )

ENDROUTINE

{******************************************************************************}

ROUTINE report_list ( self )

{
* Summary    : Connects the user to infomaker and provides the list of reports
*              then sets the prompts text, with the selected report name.
*
* Parameters : self - prompt
*
* Return     : None
*
*******************************************************************************}


	DECLARE pbl_name , rep_list , report_name , imprint_path , imprint_obj, export_syn,
		arg_array

	pbl_name = SELECT infomaker_link . library

	report_name = SELECT infomaker_link . report

	IF report_name = EMPTY THEN
		report_name = ""
	ENDIF

	imprint_path = client_get_imprint_path ()

	IF imprint_path = EMPTY THEN

	    flash_message ( 
	    	GET_USER_MESSAGE ( "IMPRINT_CONNECT_UNSUCCESSFUL" , 1 ) , TRUE )

	ELSE

	    define_imprint_class ()

	    CREATE OBJECT IMPRINT , imprint_obj

	    imprint_obj . create_ole_object ()

	    imprint_obj . reset_ole_object ()

	    imprint_obj . login ()

	    IF GLOBAL ( "OLEIMPRINT_SERVER_SIDE" ) THEN

		imprint_obj . library = lib_utils_logical_containing_file ( "smp$imprint",
		                                                            pbl_name     )

		IF imprint_obj . library <> EMPTY THEN
			imprint_obj . library = imprint_obj . library : "\" : pbl_name
		ELSE
			imprint_obj . library = pbl_name
		ENDIF

            ELSE

		imprint_obj . library = imprint_path : "\" : pbl_name

	    ENDIF

	    imprint_obj . set_PBL_Library ( imprint_obj . library )

	    rep_list = imprint_obj . list_reports ()

	    rep_array = convert_list_to_array ( rep_list )

	    imprint_obj . ole_object = EMPTY

	    ARRAY_SORT ( rep_array , ARRAY_SORT_ASCENDING )

	    BROWSE_ON_ARRAY ( 20 , report_name , rep_array )

	    self . set_text ( report_name )

	ENDIF


ENDROUTINE


{******************************************************************************}

GLOBAL
ROUTINE convert_list_to_array ( VALUE rep_list  )

{
* Summary    : Takes a string, inwhich this case is a list of report names,
*              and puts them in an array.
*
* Parameters : rep_list - string
*
* Return     : rep_array - array of reports
*
*******************************************************************************}

    DECLARE row_count, rep_txt, sep_pos, rep_txt_1, rep_txt_2,rep_txt_3,
            lenstr, lenstr_1, lenstr_2, col_1, col_2 , rep_array

    ARRAY rep_array

    row_count = 0
    sep_pos   = 1

    WHILE ( rep_list <> "" ) AND
          ( sep_pos  >  0  ) DO

        row_count = row_count + 1
        lenstr    = STRINGLENGTH ( rep_list )
        sep_pos   = INDEX ( rep_list, ASCII(10) )
        rep_txt   = ""
        rep_txt_1 = ""
        rep_txt_2 = ""
        rep_txt_3 = ""

        IF sep_pos > 1 THEN

            rep_txt   = SUBSTRING ( rep_list, 1, sep_pos - 1 )

            col_1     = INDEX ( rep_txt, ASCII (9) )

            IF col_1 > 0 THEN

                rep_txt_1 = SUBSTRING ( rep_txt, 1, col_1-1 )

                lenstr_1  = STRINGLENGTH ( rep_txt )
                rep_txt_2 = SUBSTRING ( rep_txt, col_1+1 , lenstr_1 - col_1 )

                col_2     = INDEX ( rep_txt_2, ASCII (9) )

                lenstr_2  = STRINGLENGTH ( rep_txt_2 )
                rep_txt_3 = SUBSTRING ( rep_txt_2, col_2 + 1 , lenstr_2 - col_2 )
                rep_txt_2 = SUBSTRING ( rep_txt_2, 1 , col_2 - 1 )


            ELSE

                rep_txt_1 = rep_txt

            ENDIF

        ENDIF

        rep_array [ row_count, 1 ] = rep_txt_1
        rep_array [ row_count, 2 ] = rep_txt_3

        rep_list = SUBSTRING ( rep_list, sep_pos + 1, lenstr - sep_pos )
        
    ENDWHILE

    RETURN ( rep_array )

ENDROUTINE { convert_list_to_array }

{******************************************************************************}

GLOBAL
ROUTINE strip_off_filename ( self )

{
* Summary    : Wrap around function for strip_file_from_path, takes prompt
*              value, strips then sets prompt value.
*
* Parameters : self - prompt
*
* Return     : None
*
*******************************************************************************}

    DECLARE new_file_name, file_name
    
    new_file_name = self . value
    
    IF ( new_file_name <> EMPTY ) AND ( NOT BLANK ( new_file_name ) ) THEN

        file_name = strip_file_from_path ( new_file_name )

        self . value = file_name
        self . set_text ( file_name )

    ENDIF

ENDROUTINE { strip_off_filename }

{******************************************************************************}

ROUTINE valid_infomaker_report ( VALUE pbl, VALUE report )

{
* Summary    : Connects the user to infomaker and provides the list of reports
*              then checks the pass report is valid.
*
* Parameters : pbl - Powerbuilder Library
*              report - infomaker report to check
*
* Return     : Boolean based on it report is found in pbl
*
*******************************************************************************}


	DECLARE valid_report, imprint_path, imprint_obj, rep_list, rep_array,
	count


	valid_report = FALSE
	count = 0

	imprint_path = client_get_imprint_path ()

	IF imprint_path = EMPTY THEN

		flash_message ( 
		GET_USER_MESSAGE ( "IMPRINT_CONNECT_UNSUCCESSFUL" , 1 ) , TRUE )

	ELSE

		IF GLOBAL ( "OLEIMPRINT_SERVER_SIDE" ) THEN

			imprint_path = lib_utils_logical_to_string ( "smp$imprint" )

		ENDIF

		define_imprint_class ()

		CREATE OBJECT IMPRINT , imprint_obj

		imprint_obj . create_ole_object ()

		imprint_obj . reset_ole_object ()

		imprint_obj . login ()

		IF GLOBAL ( "OLEIMPRINT_SERVER_SIDE" ) THEN

			imprint_obj . library = lib_utils_logical_containing_file ( "smp$imprint",
			                                                            pbl           )

		ELSE

			imprint_obj . library = imprint_path

		ENDIF

		IF imprint_obj . library <> EMPTY THEN

			imprint_obj . library = imprint_obj . library : "\" : pbl

			imprint_obj . set_PBL_Library ( imprint_obj . library )

			rep_list = imprint_obj . list_reports ()

			rep_array = convert_list_to_array ( rep_list )

			report = STRIP ( TOUPPER (report) )
			WHILE ( count < size_of_array ( rep_array ) ) DO

				count = count + 1

				IF report = TOUPPER ( STRIP ( rep_array [ count , 1 ] )  ) THEN

					valid_report = TRUE

				ENDIF

			ENDWHILE

		ENDIF

	ENDIF

	RETURN ( valid_report )

ENDROUTINE { valid_infomaker_report }


{******************************************************************************}



{******************************************************************************}
{******************************************************************************}
{******************************************************************************}
